diff --git a/.gitignore b/.gitignore
index 25a7384..d93dfdd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1,3 @@
 *.o
 *.exe
+record.txt
diff --git a/cpptet_pubsub_v1.2/KbdCtrl.cpp b/cpptet_pubsub_v1.2/KbdCtrl.cpp
index d89df78..dc7c62f 100644
--- a/cpptet_pubsub_v1.2/KbdCtrl.cpp
+++ b/cpptet_pubsub_v1.2/KbdCtrl.cpp
@@ -21,13 +21,13 @@ bool KbdCtrl::isStdinReadable(void)
   return FD_ISSET(STDIN_FILENO, &rdfs);
 }
 
-char KbdCtrl::getChar() 
+char KbdCtrl::getChar()
 {
   extern int tty_cbreak(int fd);
   extern int tty_reset(int fd);
   char ch = -1;
   int n;
-  
+
   //while (true) {
   tty_cbreak(0);
   if (isStdinReadable()) {
@@ -58,13 +58,13 @@ void KbdCtrl::handle(Msg *msg)
   }
 }
 
-void KbdCtrl::run() 
+void KbdCtrl::run()
 {
   //win->printw(name + ".run() begins.\n");
   Msg *msg;
   while (true) {
     mtx.lock();
-    if (que.empty()) 
+    if (que.empty())
       msg = NULL;
     else {
       msg = que.front();
@@ -77,6 +77,7 @@ void KbdCtrl::run()
       break;
 
     handle(msg);
+    delete msg;
   }
   //win->printw(name + ".run() ends.\n");
 }
diff --git a/cpptet_pubsub_v1.2/Makefile b/cpptet_pubsub_v1.2/Makefile
index 4ccecb1..9ca302f 100644
--- a/cpptet_pubsub_v1.2/Makefile
+++ b/cpptet_pubsub_v1.2/Makefile
@@ -2,7 +2,7 @@
 CC=g++
 CFLAGS=-g -I. -fpermissive -lncursesw
 LDFLAGS=
-MAIN_OBJS=main.o Matrix.o Window.o MsgPubSub.o View.o Model.o TimeCtrl.o KbdCtrl.o ttymodes.o Tetris.o CTetris.o Record.o
+MAIN_OBJS=main.o Matrix.o Window.o MsgPubSub.o View.o Model.o TimeCtrl.o KbdCtrl.o ttymodes.o Tetris.o CTetris.o Record.o Replay.o
 
 all:: main.exe
 
@@ -15,5 +15,5 @@ main.exe: $(MAIN_OBJS)
 %.o: %.cpp $(DEPS)
 	$(CC) -c -pthread -o $@ $< $(CFLAGS)
 
-clean: 
+clean:
 	rm -f *.exe *.o *~ *.stackdump
diff --git a/cpptet_pubsub_v1.2/Model.cpp b/cpptet_pubsub_v1.2/Model.cpp
index 36849d8..acc2980 100644
--- a/cpptet_pubsub_v1.2/Model.cpp
+++ b/cpptet_pubsub_v1.2/Model.cpp
@@ -40,7 +40,7 @@ int T6D0[] = { 1, 1, 0, 0, 1, 1, 0, 0, 0, -1 };//Z
 int T6D1[] = { 0, 0, 1, 0, 1, 1, 0, 1, 0, -1 };
 int T6D2[] = { 0, 0, 0, 1, 1, 0, 0, 1, 1, -1 };
 int T6D3[] = { 0, 1, 0, 1, 1, 0, 1, 0, 0, -1 };
- 
+
 int *setOfCBlockArrays[] = {
   T0D0, T0D1, T0D2, T0D3,
   T1D0, T1D1, T1D2, T1D3,
@@ -72,7 +72,7 @@ Model::Model(Window *w, string n, bool record_mode, bool replay_mode): omsg(MSG_
   state = TetrisState::NewBlock;
   if (mode == ModelMode::RECORD)
     srand((unsigned int)time(NULL));
-};
+}
 
 void Model::output_message(char key)
 {
@@ -98,17 +98,19 @@ void Model::handle(Msg *msg)
   if ((msg->what & MSG_KEY) != MSG_KEY)
     return;
 
-  char key = msg->key;
-  if (key == 'q') 
-    shutdown_whole_graph();
-
   if (state == TetrisState::NewBlock && mode == ModelMode::RECORD)
     handle_newblock();
 
+  char key = msg->key;
   //win->printw(name + ": key = " + key + "\n");
   state = board->accept(key);
   output_message(key);
 
+  // check game quit after output_message
+  // in order to save last 'q' into record.txt
+  if (key == 'q' || state == TetrisState::Finished)
+    shutdown_whole_graph();
+
   if (state == TetrisState::NewBlock && mode == ModelMode::RECORD)
     handle_newblock();
 
diff --git a/cpptet_pubsub_v1.2/MsgPubSub.cpp b/cpptet_pubsub_v1.2/MsgPubSub.cpp
index 695c25b..3124101 100644
--- a/cpptet_pubsub_v1.2/MsgPubSub.cpp
+++ b/cpptet_pubsub_v1.2/MsgPubSub.cpp
@@ -1,6 +1,6 @@
 #include "MsgPubSub.h"
 
-void Sub::update(Msg *m) 
+void Sub::update(Msg *m)
 {
 #if 1 // added by khkim
   Msg *m_copy = new Msg(m);
@@ -16,14 +16,14 @@ void Sub::update(Msg *m)
 #endif
 }
 
-void Sub::run() 
+void Sub::run()
 {
   //win->printw(name + ".run() begins.\n");
   while (true) {
     unique_lock<mutex> uqlck(mtx);
     if (que.empty())
       cv.wait(uqlck, [&]{ return !que.empty(); } );
-    
+
     Msg *msg = que.front();
     que.pop();
     uqlck.unlock();
@@ -33,21 +33,21 @@ void Sub::run()
 	    break;
 
     handle(msg);
-  
+
 #if 1 // added by khkim
-    delete msg; 
+    delete msg;
 #endif
   }
   //win->printw(name + ".run() ends.\n");
-};
+}
 
-void Pub::addSubs(Sub* sub) 
+void Pub::addSubs(Sub* sub)
 {
   subs[nsubs] = sub;
   nsubs++;
 }
-  
-void Pub::notifySubs(Msg *m) 
+
+void Pub::notifySubs(Msg *m)
 {
   for(int i=0; i < nsubs; i++)
     subs[i]->update(m);
diff --git a/cpptet_pubsub_v1.2/Record.cpp b/cpptet_pubsub_v1.2/Record.cpp
index 1a52779..62d56bd 100644
--- a/cpptet_pubsub_v1.2/Record.cpp
+++ b/cpptet_pubsub_v1.2/Record.cpp
@@ -1,10 +1,10 @@
 #include "Record.h"
 
-Record::Record(Window *w, string n) 
+Record::Record(Window *w, string n): fout("record.txt")
 {
   win = w;
   name = n;
-};
+}
 
 void Record::handle(Msg *msg)
 {
@@ -15,6 +15,7 @@ void Record::handle(Msg *msg)
 
   char key = msg->key;
   win->printw(name + ": key = " + key + "\n");
+  fout << key << flush;
 }
 
 
diff --git a/cpptet_pubsub_v1.2/Record.h b/cpptet_pubsub_v1.2/Record.h
index eb3a2a7..877a979 100644
--- a/cpptet_pubsub_v1.2/Record.h
+++ b/cpptet_pubsub_v1.2/Record.h
@@ -3,6 +3,7 @@
 #include <queue>
 #include <mutex>
 #include <condition_variable>
+#include <fstream>
 
 #include "MsgPubSub.h"
 #include "Window.h"
@@ -11,7 +12,8 @@
 class Record: public Sub {
  private:
   Window *win;     // console window
-  
+  ofstream fout;
+
  public:
   Record(Window *w, string n);
   void handle(Msg *msg);
diff --git a/cpptet_pubsub_v1.2/Replay.cpp b/cpptet_pubsub_v1.2/Replay.cpp
new file mode 100644
index 0000000..3b1463f
--- /dev/null
+++ b/cpptet_pubsub_v1.2/Replay.cpp
@@ -0,0 +1,46 @@
+#include "Replay.h"
+
+Replay::Replay(Window *w, string n): fin("record.txt")
+{
+  win = w;
+  name = n;
+}
+
+void Replay::handle(Msg *msg)
+{
+  //win->printw(name + ".handle() called.\n");
+  usleep(500 * 1000);
+
+  if (fin.eof()) {
+    return;
+  }
+  char key;
+  // add noskipws for space(block drop) key
+  fin >> noskipws >> key;
+  Msg omsg(MSG_KEY, key, NULL);
+  notifySubs(&omsg); // omsg will be copied
+}
+
+void Replay::run()
+{
+  //win->printw(name + ".run() begins.\n");
+  Msg *msg;
+  while (true) {
+    mtx.lock();
+    if (que.empty())
+      msg = NULL;
+    else {
+      msg = que.front();
+      que.pop();
+    }
+    mtx.unlock();
+    //win->printw(name + ".run() wakes up.\n");
+
+    if (msg && msg->what == MSG_END)
+      break;
+
+    handle(msg);
+    delete msg;
+  }
+  //win->printw(name + ".run() ends.\n");
+}
diff --git a/cpptet_pubsub_v1.2/Replay.h b/cpptet_pubsub_v1.2/Replay.h
new file mode 100644
index 0000000..d7a4268
--- /dev/null
+++ b/cpptet_pubsub_v1.2/Replay.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include <unistd.h>
+#include <fstream>
+
+#include "MsgPubSub.h"
+#include "Window.h"
+
+class Replay: public Sub, public Pub {
+ private:
+  Window *win; // console window
+  ifstream fin;
+
+ public:
+  Replay(Window *w, string n);
+  void run();
+  void handle(Msg *msg);
+};
diff --git a/cpptet_pubsub_v1.2/TimeCtrl.cpp b/cpptet_pubsub_v1.2/TimeCtrl.cpp
index 484330d..1afbe0f 100644
--- a/cpptet_pubsub_v1.2/TimeCtrl.cpp
+++ b/cpptet_pubsub_v1.2/TimeCtrl.cpp
@@ -15,13 +15,13 @@ void TimeCtrl::handle(Msg *msg)
   notifySubs(&key_msg);
 }
 
-void TimeCtrl::run() 
+void TimeCtrl::run()
 {
   //win->printw(name + ".run() begins.\n");
   Msg *msg;
   while (true) {
     mtx.lock();
-    if (que.empty()) 
+    if (que.empty())
       msg = NULL;
     else {
       msg = que.front();
@@ -34,6 +34,7 @@ void TimeCtrl::run()
 	    break;
 
     handle(msg);
+    delete msg;
   }
   //win->printw(name + ".run() ends.\n");
-};
+}
diff --git a/cpptet_pubsub_v1.2/main.cpp b/cpptet_pubsub_v1.2/main.cpp
index e397ef4..fcb355a 100644
--- a/cpptet_pubsub_v1.2/main.cpp
+++ b/cpptet_pubsub_v1.2/main.cpp
@@ -12,19 +12,20 @@
 #if 1
 #include "Record.h"
 #endif
+#include "Replay.h"
 
 using namespace std;
 
 vector<Sub*> sub_list;
 Msg msg_end(MSG_END, 0, NULL);
 
-void init_screen() 
+void init_screen()
 {
   setlocale(LC_ALL, ""); // for printing a box character
   initscr();         // initialize the curses screen
   start_color(); // start using colors
   // init_pair(index, fg color, bg color);
-  init_pair(1, COLOR_RED,     COLOR_BLACK); 
+  init_pair(1, COLOR_RED,     COLOR_BLACK);
   init_pair(2, COLOR_GREEN,   COLOR_BLACK);
   init_pair(3, COLOR_YELLOW,  COLOR_BLACK);
   init_pair(4, COLOR_BLUE,    COLOR_BLACK);
@@ -33,7 +34,7 @@ void init_screen()
   init_pair(7, COLOR_WHITE,   COLOR_BLACK);
 }
 
-void close_screen() 
+void close_screen()
 {
   endwin();
 }
@@ -46,7 +47,7 @@ void shutdown_whole_graph()
 	  sub_list[i]->update(&msg_end);
 }
 
-int main(int argc, char *argv[]) 
+int main(int argc, char *argv[])
 {
   vector<thread*> task_list;
   thread *task;
@@ -74,7 +75,7 @@ int main(int argc, char *argv[])
     cout << "usage: " << argv[0] << " [record/replay]" << endl;
     exit(1);
   }
-#endif 
+#endif
 
   init_screen();
 
@@ -88,13 +89,19 @@ int main(int argc, char *argv[])
   View *left_view = new View(&left_win, &bttm_win, "left_view");
   sub_list.push_back(left_view);
 #if 1 // added by khkim
-  Record *left_record = new Record(&bttm_win, "left_record");
-  sub_list.push_back(left_record);
+  Record *left_record = NULL;
+  // Guard to avoid recreatig record.txt on replay mode
+  if (record_mode) {
+    left_record = new Record(&bttm_win, "left_record");
+    sub_list.push_back(left_record);
+  }
   Model *left_model = new Model(&bttm_win, "left_model", record_mode, replay_mode);
 #else
   Model *left_model = new Model(&bttm_win, "left_model");
 #endif
   sub_list.push_back(left_model);
+  Replay *left_replay = new Replay(&bttm_win, "left_replay");
+  sub_list.push_back(left_replay);
   TimeCtrl *time_ctrl = new TimeCtrl(&bttm_win, "time_ctrl");
   sub_list.push_back(time_ctrl);
   KbdCtrl *kbd_ctrl = new KbdCtrl(&bttm_win, "kbd_ctrl");
@@ -102,16 +109,24 @@ int main(int argc, char *argv[])
 
   // connect tasks to compose the graph
 #if 1 // added by khkim
-  left_model->addSubs(left_record);
+  if (left_record) {
+    left_model->addSubs(left_record);
+  }
 #endif
   left_model->addSubs(left_view);
-  time_ctrl->addSubs(left_model);
-  kbd_ctrl->addSubs(left_model);
+  if (replay_mode) {
+    left_replay->addSubs(left_model);
+  } else {
+    time_ctrl->addSubs(left_model);
+    kbd_ctrl->addSubs(left_model);
+  }
 
   // run a thread for each task
 #if 1 // added by khkim
-  task = new thread(&Record::run, left_record);
-  task_list.push_back(task);
+  if (left_record) {
+    task = new thread(&Record::run, left_record);
+    task_list.push_back(task);
+  }
 #endif
   task = new thread(&View::run, left_view);
   task_list.push_back(task);
@@ -121,6 +136,8 @@ int main(int argc, char *argv[])
   task_list.push_back(task);
   task = new thread(&KbdCtrl::run, kbd_ctrl);
   task_list.push_back(task);
+  task = new thread(&Replay::run, left_replay);
+  task_list.push_back(task);
 
   // message flow begins...
   //sleep(10);
@@ -129,8 +146,8 @@ int main(int argc, char *argv[])
   //shutdown_whole_graph();
 
   // wait for each task to be terminated
-  for (int i=0; i < task_list.size(); i++) 
-	  task_list[i]->join(); 
+  for (int i=0; i < task_list.size(); i++)
+	  task_list[i]->join();
 
   close_screen();
 
